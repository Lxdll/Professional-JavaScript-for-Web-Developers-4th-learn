# 4.2 执行上下文与作用域

1. 每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。

2. 全局上下文是最外层的上下文。在浏览器中，全局上下文就是我们常说的 `window` 对象。因此所有通过 `var` 定义的全局变量和函数都会成为 `window` 对象的属性和方法。使用 `let` 和 `const` 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。

3. 上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。

4. 每个函数调用都有自己的自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。

5. 上下文中的代码在执行的时候，会创建变量对象的一个作用域链。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。

6. 代码执行时的标识符解析时通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。

![作用域链](作用域链.png)

## 4.2.2 变量声明

1. 使用 `var` 的函数作用域声明<br/>
   在使用 `var` 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。
2. `var` 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫做 “提升”。
3. ES6 新增的 `let` 关键字跟 `var` 很相似，但它的作用域是块级的。块级作用域由最近的一对包括花括号 {} 界定。
4. `let` 与 `var` 的另一个不同之处是在同一作用域内不能声明两次。重复的 `var` 声明会被忽略，而重复的 `let` 声明会抛出 `SyntaxError。`
5. 使用 `const` 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。
6. `const` 声明只应用到顶级原语或者对象。换句话说，赋值为对象的 `const` 变量不能再被重新赋值为其他引用值，但对象的键则不受限制。

```JavaScript
const o1 = {}
ol = {} // TypeError: 给常量赋值

const o2 = {}
o2.name = 'Jake'
console.log(o2.name) // Jake
```
